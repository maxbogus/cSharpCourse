# ДЗ 5. Reflection.

**Задание**

Разработайте консольное приложение с плагинами, подключаемыми на этапе исполнения через reflection.

**Требования**

- при запуске приложение загружает плагины из соседней папки `plugins`
- каждый загруженный плагин регистрирует обработчик команды запуска
- когда пользователь вводит текст в консоли, приложение проверяет, совпадает ли первое слово введённого текста с одной из зарегистрированных команд запуска
- если совпадает, то приложение запускает обработчик из плагина, отправляя ему на вход аргументы - часть текста, введённого пользователем, после команды запуска
- в приложении есть встроенная команда `help`, обработчик которой распечатывает все команды (в том числе help)

**Указания**

Для плагинов потребуется интерфейс. Он решит сразу 3 задачи:
1. Авторам плагинов будет проще выдержать контракт интеграции с вашим приложением
2. Вам будет удобно использовать этот интерфейс для работы с экземплярами плагинов
3. По этому интерфейсу вы найдёте в сторонних сборках плагины

Этот интерфейс потребуется и вашему приложению, и авторам плагинов. Поэтому его необходимо вынести в отдельную сборку. Создайте для этого в вашем solution второй проект - dll.

После сборки приложения вы получите 2 сборки - исполняемую (консольное приложение) и библиотеку с интерфейсом плагина (dll). Библиотека понадобится авторам плагинов. Автор плагина создаёт проект библиотеки, и в её зависимости добавляет вашу библиотеку. Остаётся лишь реализовать интерфейс и плагин готов. Для удобства разработки можете и приложение с библиотекой контракта, и плагины держать в одном solution. В свойствах проектов плагинов можете настроить output path так, чтобы после сборки они попадали в папку plugins в output path вашего основного приложения.

Для загрузки плагинов:
1. Найдите все файлы ".dll" в папке `plugins`
2. Загрузите сборки с помощью `Assembly.LoadFrom`. Вы получите экземпляры Assembly - типа, описывающего метаданные сборки
3. В полученных экземплярах ищите типы, реализующие ваш интерфейс. Сравнивайте не по имени, а с `typeof(ваш_интерфейс)`
4. Для найденных типов найдите конструктор без параметров и создайте экземпляры
5. Теперь можно работать с ними так, как будто это и не плагины вовсе, а данные вашей программы.

Пример интерфейса плагина:
```cs
public interface IPlugin
{
    string Command { get; }

    void Run(string args);
}
```
